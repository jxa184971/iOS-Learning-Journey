## 什么是MVVM?
**M** - model 

**V** - View 

**VM** - ViewModel是View和Model之间的中介

**MVVM**的出现主要是为了**解决在开发过程中Controller越来越庞大的问题**，变得难以维护，所以MVVM把**数据加工**(例如请求数据,将json格式数据转化为对象)的任务从Controller中解放了出来，使得Controller只需要专注于数据调配的工作，ViewModel则去负责数据加工并通过通知机制让View响应ViewModel的改变。

## 什么是KVC和KVO？
### KVC (Key-Value Coding)
**KVC**（Key-value coding）键值编码，就是指iOS的开发中，可以允许开发者通过Key名直接访问对象的属性，或者给对象的属性赋值，而不需要调用明确的存取方法。这样就可以在运行时（runtime）动态地访问和修改对象的属性，而不是在编译时确定。

```objective-c
//直接通过Key来取值
- (nullable id)valueForKey:(NSString *)key; 

//通过Key来设值
- (void)setValue:(nullable id)value forKey:(NSString *)key;
```

使用场景
* 动态地取值和设值 - 利用KVC动态的取值和设值是最基本的用途了。
* 用KVC来访问和修改私有变量 - 对于类里的私有属性，Objective-C是无法直接访问的，但是KVC是可以的。
* Model和字典转换 - 这是KVC强大作用的又一次体现，KVC和Objc的runtime组合可以很容易的实现Model和字典的转换。
* 修改一些控件的内部属性 - 很多UI控件都由很多内部UI控件组合而成的，但是Apple没有提供这访问这些控件的API，这样我们就无法正常地访问和修改这些控件的样式。而KVC在大多数情况可下可以解决这个问题。最常用的就是个性化UITextField中的placeHolderText了。
* 操作集合 - Apple对KVC的valueForKey:方法作了一些特殊的实现，比如说NSArray和NSSet这样的容器类就实现了这些方法。所以可以用KVC很方便地操作集合。

### KVO (Key-Value Observing)
**KVO**即Key-Value Observing, 键值观察, 它是一种观察者模式的衍生。其基本思想是，对目标对象的某属性添加观察，当该属性发生变化时，通过触发观察者对象实现的KVO接口方法，来自动的通知观察者。

主要应用场景
应用场景：当数据模型的数据发生改变时，视图组件能动态的更新，及时显示数据模型更新后的数据。比如：监听scrollView的contentOffset属性，来完成用户滚动时动态改变某些控件的属性实现效果，包括渐变导航栏、下拉刷新控件等效果。

## 属性修饰词
#### assign （ARC/MRC）
1. assign在ARC和MRC中都是存在的 
2. assign一般用来修饰基本数据类型 
3. assign也可用来修饰对象，但是，对象的引用计数不会+1（与strong的区别）。
 PS：assign如果用来修饰对象属性，当对象销毁后指针不会指向nil，会出现野指针错误(与weak的区别) 

#### weak（ARC）
1. 弱指针是针对对象的修饰词, 就是说它**不能修饰基本数据类型**。 
2. weak修饰的对象，引用计数不会+1，即直接赋值 
3. 弱引用是为打破循环引用而生的 
4. 它所指向的对象如果被销毁, 它会指向nil, 不会报野指针错误

#### strong（ARC）
1. 直接赋值，对象引用计数+1 
2. 功能等价于MRC里面的retain

#### copy（ARC/MRC）
1. 在MRC时，release旧对象(旧对象计数器-1), copy新对象(新对象计数器+1) , 然后指向新对象。 
2. 在ARC时是这么干的copy新对象(新对象计数器+1), 然后指向新对象。

#### 原子属性（atomic）和非原子属性（nonatomic）（ARC/MRC）

非原子属性(nonatomic): 
1. 不对`set`方法加锁`（@synchronized）`,互斥锁是利用线程同步实现的 , 意在保证同一时间只有一个线程调用`set`方法 。 
2. 性能好 
3. 线程不安全

原子属性(atomic): 
1. 原子属性就是对生成的`set`方法加互斥锁 `@synchronized(锁对象)`
2. 需要消耗系统资源 
3. 还有`get`方法 , 要是同时`set`和`get` 一起调用还是会有问题的 . 所以即使用了`atomic`修饰还是不够安全.

#### readOnly(只读)、readWrite(读写)

readOnly： 
1. 只读属性，意味着只合成getter方法 
2. 不想把暴露的属性被别人替换，可以使用readOnly修饰

readWrite： 
1. 生成getter和setter方法 
2. 不用readOnly修饰时候，默认为readWrite

## 野指针和空指针
#### 空指针
1. 没有存储任何内存地址的指针就称为空指针(NULL指针)
2. 空指针就是被赋值为0的指针，在没有被具体初始化之前，其值为0。

#### 野指针
"野指针"不是NULL指针，是指向"垃圾"内存（不可用内存）的指针。

例如：
```
Student *stu = [[Student alloc] init];
[stu setAge:10];

// stu接收到release消息后，会马上被销毁，所占用的内存将会被回收。
[stu release]; 

//但是stu对象仍然指向该内存地址（垃圾内存），导致出现野指针
[stu setAge:10]; 
```

## AppDelegate Lifecycle
1. 程序的入口
进入main函数, 设置AppDelegate称为函数的代理

2. 程序完成加载
`-[AppDelegate application:didFinishLaunchingWithOptions:]`

3. 创建window窗口

4. 程序被激活
`-[AppDelegate applicationDidBecomeActive:]`

5. 当点击command+H时
5.1. 程序取消激活状态
`-[AppDelegate applicationWillResignActive:]`
5.2 程序进入后台
`-[AppDelegate applicationDidEnterBackground:]`
6. 点击进入工程
6.1. 程序进入前台
`-[AppDelegate applicationWillEnterForeground:]`
6.2. 程序被激活
`-[AppDelegate applicationDidBecomeActive:]`

## UIViewController Lifecycle
`init()`
`loadView()`
`viewDidLoad()`
`viewWillAppear`
`viewWillLayoutSubviews()` - optional
`viewDidLayoutSubviews()` - optional
`viewDidAppear()`
`viewWillDisappear()`
`viewDidDisappear()`
`dealloc()`
`deinit()`
`didReceiveMemoryWarning()` - optional

PS: 若`loadView()`没有加载view，`viewDidLoad()` 会一直调用 `loadView()`加载view，因此构成了死循环，程序即卡死。

## block的三种使用方法
1. block作为类的property使用
这种方式可以作为替代delegate的方式来进行消息传递。
```objective-c
//在类声明中 以Person为例
@property (nonatomic, copy) void(^blockName)();
 
//使用一
self.person.blockName = ^(){
    NSLog(@"将block当做属性值保存起来");
};

//使用二
void(^block03)() =^(){
    NSLog(@"将block当做属性值保存起来");
};
self.person.blockName = block03;
```

2. 把block当做方法的参数传入 
```objective-c
//在类声明中 以Person为例
- (void)eat:(void(^)(int count))block;

//使用
Person *p = [[Person alloc]init];
[p eat:^(int count){
    NSLog(@"吃了%d个馒头",count);
}];
```

3. 把block当做方法的返回值
```objective-c
//在类声明中 以Person为例
- (int(^)(int))run;

.m中实现
- (int(^)(int))run {
    return ^(int meter){
        NSLog(@"跑了%@米", meter);
        return meter;
    };
}

//使用
int a = self.person.run(10);
```

4. block的声明
```objective-c
//typedef声明
typedef void(^BlockName)(int b);

//类中的属性声明
@property (nonatomic, copy) BlockName block;
```
 
## block循环引用产生的原因, 以及怎么处理。
一个对象的Block属性是使用copy来修饰，当Block被copy时，会对block中用到的对象产生**强引用**(ARC)或者**引用计数加一**(MRC)。当我们使用Block时,如果Block方法又引用了对象,如使用`self.`来引用对象的属性,这就会造成循环引用。

解决办法为使用__weak或者__block前缀来修饰self。
```objective-c
__weak typeof(self) weakSelf = self;

self.completeBlock = ^{
    weakSelf.completeButton.enabled = YES;
};
```

## block、delegate和NSNotification的区别
三者都是用于消息的传递，但各自有所不同。

#### delegate
* “一对一”，对同一个协议，一个对象只能设置一个代理delegate。
* 使用delegate传递消息相比block更加规范及安全。可以通过判断代理是否存在，代理是否实现协议来确保消息传递的安全性。
* delegate主要应用于有多个方法需要代理执行的时候，这样就可以只定义一个delegate，而不需要定义多个block或者添加多个Notification。

#### block
* block和delegate一样，一般都是“一对一”之间通信交互
* 可以作为方法来传递，也可以作为属性来传递
* 写法更简练，不需要写protocol、函数等等 
* block可以使用上下文变量，使用起来更加方便，但是要注意使用weak或block来声明上下文变量，以免形成循环引用

#### NSNotification
* “一对多”的消息传递方式
* 它不需要确定是哪个对象来执行具体代码，而只需要发送通知告之监听者，监听者收到通知后自行处理消息
* 注意监听者需要在销毁时移除自身的监听，否则会导致内存无法释放

## 设计一个单例模式
单例模式的定义： 一个单例类，在整个程序中只有一个实例，并且提供一个类方法供全局调用，在编译时初始化这个类，然后一直保存在内存中，到程序（APP）退出时由系统自动释放这部分内存。常用于工具类。

#### 方法一 dispatch_once_t
苹果官方推荐开发者使用`dispatch_once_t`来创建单例
```objective-c
static TPUserDefault *userDefaultsInstance

+(TPUserDefault *)defaultInstance
{
    static dispatch_once_t oneToken;
    dispatch_once(&oneToken, ^{
        userDefaultsInstance = [[TPUserDefault alloc]init];
    });
    return userDefaultsInstance;
}
```

#### 方法二 @synchronized
```objective-c
static TPUserDefault *userDefaultsInstance

+(TPUserDefault *)defaultInstance
{
    @synchronized(self) {
        if (userDefaultsInstance == nil) {
            userDefaultsInstance = [[TPUserDefault alloc]init];
        }
    });
    return userDefaultsInstance;
}
```

## 类别（Category）与扩展（Extension）
#### 类别（Category）
有大量的子类，需要添加公用方法，但又无法修改它们的父类的情形。类别（Category）可以在不修改原来类的基础上，为一个类扩展方法。最主要的用法：给系统自带的类扩展方法。也可以在不修改父类的情况下，在分类中重写父类的方法。
类别

1. category只能添加**方法**，不能添加**成员变量**。
2. 分类中可以访问原来类中的成员变量，但是只能访问@protect和@public属性。
3. 添加方法加上前缀，添加方法会覆盖父类的同名方法，可以防止意外覆盖，也防止被别人覆盖。

**分类优先级执行**
1. 本类和分类的话，分类优先于本类的方法
2. 如果有两个分类中都实现了相同的方法，执行顺序是 targets->Build Phases->Complie Source，顺序是从上到下。

#### 类扩展（extension）
类扩展可以理解为Category的其中的一种，可以用来给当前类添加属性和新方法。
1. 类扩展的属性和方法都是**私有的**（也可以定义在.h中，这样就是共有的）
2. 类扩展中的方法是一定要实现的方法。类别Category没有这种限制。

```objective-c
// 类扩展是写在.m中的
@interface ViewController ()
@property (nonatomic, strong) NSString *boss;
- (void)bossAngry; // 扩展方法
@end
```

## runtime
Objective-C是一个动态语言，这意味着它不仅需要一个编译器，也需要一个运行时系统来**动态**得创建类和对象、进行消息传递和转发。这就是runtime库的作用。

常见的应用方向：
1. 实现字典和模型的自动转换
2. 关联对象(Objective-C Associated Objects)给分类增加属性，多用于系统库的类
    `void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)`
3. 方法替换，多用于系统库的方法替换

### 消息传递
一个对象的方法像这样`[obj foo]`，编译器转成消息发送`objc_msgSend(obj, foo)`，Runtime时执行的流程是这样的：

1. 通过`obj`的`isa指针`找到它的`class`;
2. 在`class`的`objc_cache`中找`foo`， 如果找到直接跳转到5;
3. 在`class`的`objc_method_list`找`foo`，如果找到直接跳转到5;
4. 如果`class`中没到`foo`，继续往它的`superclass`中找，重复2~3步骤;
5. 一旦找到`foo`这个函数，就去执行它的实现`IMP`。

这也就是`objc_class`中另一个重要成员`objc_cache`做的事情 - 再找到`foo`之后，把`foo`的`method_name`作为key，`method_imp`作为value给存起来。当再次收到`foo`消息的时候，可以直接在cache里找到，避免去遍历`objc_method_list`。

![](https://github.com/jxa184971/iOS-Learning-Journey/blob/master/PIC/301129-cc9c0a7ffb147fed.png)

### 消息转发
进行一次发送消息会在相关的类对象中搜索方法列表，如果找不到则会沿着继承树向上**一直搜索直到继承树根部**（通常为NSObject），如果还是**找不到**并且**消息转发都失败了**就回执行`doesNotRecognizeSelector:`方法报`unrecognized selector`错。那么消息转发到底是什么呢？接下来将会逐一介绍最后的三次机会。

* 动态方法解析
* 备用接收者
* 完整消息转发

![](https://github.com/jxa184971/iOS-Learning-Journey/blob/master/PIC/301129-a1159ef51f453da8.png)

#### 动态方法解析 - resoveInstanceMethod:
首先，Objective-C运行时会调用`+resolveInstanceMethod:`或者 `+resolveClassMethod:`，**让你有机会提供一个函数实现**。如果你添加了函数并返回YES，那运行时系统就会重新启动一次消息发送的过程。

```objective-c
- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view, typically from a nib.
    //执行foo函数
    [self performSelector:@selector(foo:)];
}

+ (BOOL)resolveInstanceMethod:(SEL)sel {
    if (sel == @selector(foo:)) {//如果是执行foo函数，就动态解析，指定新的IMP
        class_addMethod([self class], sel, (IMP)fooMethod, "v@:");
        return YES;
    }
    return [super resolveInstanceMethod:sel];
}

void fooMethod(id obj, SEL _cmd) {
    NSLog(@"Doing foo");//新的foo函数
}
```

如果resolve方法返回`NO`，运行时就会移到下一步：`forwardingTargetForSelector`。

#### 备用接收者 - forwardingTargetForSelector:
如果目标对象实现了`-forwardingTargetForSelector:`，`Runtime`这时就会调用这个方法，给你把这个消息转发给其他对象。

```objective-c
+ (BOOL)resolveInstanceMethod:(SEL)sel {
    return NO;
}

- (id)forwardingTargetForSelector:(SEL)aSelector {
    if (aSelector == @selector(foo)) {
        return [Person new];//返回Person对象，让Person对象接收这个消息
    }
    return [super forwardingTargetForSelector:aSelector];
}
```

#### 完整消息转发
如果在上一步还不能处理未知消息，则唯一能做的就是启用完整的消息转发机制了。
首先它会发送`-methodSignatureForSelector:`消息获得函数的参数和返回值类型。如果`-methodSignatureForSelector:`返回`nil`，Runtime则会发出 `-doesNotRecognizeSelector:`消息，程序这时也就挂掉了。

如果返回了一个函数签名，Runtime就会创建一个`NSInvocation`对象并发送`-forwardInvocation:`消息给目标对象。

```objective-c
+ (BOOL)resolveInstanceMethod:(SEL)sel {
    return NO;//返回NO，进入下一步转发
}

- (id)forwardingTargetForSelector:(SEL)aSelector {
    return nil;//返回nil，进入下一步转发
}

- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector {
    if ([NSStringFromSelector(aSelector) isEqualToString:@"foo"]) {
        return [NSMethodSignature signatureWithObjCTypes:"v@:"];//签名，进入forwardInvocation
    }
 
    return [super methodSignatureForSelector:aSelector];
}

- (void)forwardInvocation:(NSInvocation *)anInvocation {
    SEL sel = anInvocation.selector;

    Person *p = [Person new];
    if([p respondsToSelector:sel]) {
        [anInvocation invokeWithTarget:p];
    }else {
        [self doesNotRecognizeSelector:sel];
    }
}
```

## isKindOfClass和isMemberOfClass的区别
**isKindOfClass**来确定一个对象是否是一个类的成员，或者是派生自该类的成员

**isMemberOfClass**只能确定一个对象是否是当前类的成员

## 如何对iOS设备进行性能测试？
使用**Instruments**工具进行调试，是应用程序用来动态跟踪和分析Mac OS X 和iOS代码的实用工具。这是一个灵活而强大的工具,它让你可以跟踪一个或多个进程,并检查收集的数据。例如：可以使用Instruments查看占内存最大的方法调用是什么，然后再对其进行优化。

还可以使用模拟器的debug模式中的Color Blended Layers来进行UI检查，从而减少半透明的layer，从而减少渲染图像的消耗。

## 集成三方框架有哪些方法
1. 手动集成
2. CocoPods

#### Cocopods
CocoaPods是OS X和iOS下的一个**第三类库管理工具**，通过CocoaPods工具我们可以为项目添加被称为“Pods”的依赖库（这些类库必须是CocoaPods本身所支持的），并且可以轻松管理其版本。

CocoaPods有两个明显的优势：
1、在引入第三方库时它可以自动为我们完成各种各样的配置，包括配置编译阶段、连接器选项、甚至是ARC环境下的-fno-objc-arc配置等。
2、使用CocoaPods可以很方便地查找新的第三方库，这些类库是比较“标准的”，而不是网上随便找到的，这样可以让我们找到真正好用的类库。

在使用CocoaPods之后，我只需要将用到的第三方开源库放到一个名为Podfile的文件中，然后执行pod install。CocoaPods就会自动将这些第三方开源库的源码下载下来，并且为我的工程设置好相应的系统依赖和编译参数。

## SDWebImage的原理实现机制
1. 从内存（字典）中找图片（当这个图片在本次使用程序的过程中已经被加载过），找到直接使用。
2. 从沙盒中找（当这个图片在之前使用程序的过程中被加载过），找到使用，缓存到内存中。
3. 从网络上获取，使用，缓存到内存，缓存到沙盒

## 如何解决TableView滑动卡的问题
1. 复用cell
2. cell中的视图尽量都使用不透明的，尽量少使用动画
3. 图片加载使用异步加载
4. 如非必要，减少reloadData全部cell，只reloadRowsAtIndexPaths
5. 提前计算出cell高度后缓存

## iOS中常用的数据存储方式有哪些?（数据持久化）每种存储方式各有什么特点？每种存储方式各自在什么场景下使用？
所有的本地持久化数据存储的本质都是写文件，而且只能存到沙盒中。

数据存储的核心都是写文件。主要有四种持久化方式：属性列表，对象序列化，SQLite 数据库, CoreData

**属性列表**：应用于少量数据存储，比如登陆的用户信息，应用程序配置信息等。只有NSString ，NSArray，NSDictory，NSData，可以WriteToFile；存储的依旧是plist文件，plist文件可以存储的7种数据类型：array，dictory，string，bool，data，date，number。NSUserDefaults本质上也是plist。

**对象序列化**：最终也是存为属性列表文件，如果程序中，需要存储的时候，直接存储对象比较方便。对象序列化是将一个实现了NSCoding协议的对象，通过序列化（NSKeydArchiver）的形式，将对象中的属性抽取出来，转化成二进制流，也就是NSData，NSData可以选择write to file或者存储到NSUserdefault中。

**SQLite**： 适合大量，重复，有规律的数据存储。而且频繁的读取，删除，过滤数据，这种适合使用数据库。

**CoreData**：CoreData本质还是数据库，只不过使用起来更加面向对象，不关注二维的表结构，而是只需要关注对象，纯面向对象的数据操作方式。

## GDC多线程
#### Grand Central Dispatch
Grand Central Dispatch(GCD) 是异步执行任务的技术之一。开发者只需要定义想执行的任务并追加到适当的Dispatch Queue中，GCD就能生成必要的线程并计划执行任务。

#### Dispatch Queue
Dispatch Queue是执行处理的等待队列，通过调用dispatch_async等函数，以block的形式将任务追加到Dispatch Queue中。Dispatch Queue按照添加进来的顺序（FIFO）执行任务处理。

| Dispatch Queue分类	 | 说明 |
| --- | --- |
| Serial Dispatch Queue	 | 串行的队列，每次只能执行一个任务，并且必须等待前一个执行任务完成 |
| Concurrent Dispatch Queue	 | 一次可以并发执行多个任务，不必等待执行中的任务完成 |

```objective-c
//主线程 
dispatch_queue_t mainQueue = dispatch_get_main_queue(); 
//HIGH 
dispatch_queue_t highQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0); 
//DEFAULT 
dispatch_queue_t defaultQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); 
//LOW 
dispatch_queue_t lowQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0); 
//BACKGROUND 
dispatch_queue_t backgroundQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0);
```

#### 异步执行
```objective-c
dispatch_async(queue, ^{
  NSLog(@"1");
});
```

## runloop和线程
#### 简介
运行循环，在程序运行过程中循环做一些事情，如果没有Runloop程序执行完毕就会立即退出，如果有Runloop程序会一直运行，并且时时刻刻在等待用户的输入操作。

RunLoop可以在需要的时候自己跑起来运行，在没有操作的时候就停下来休息。充分节省CPU资源，提高程序性能。

#### 基本作用
1. 保持程序持续运行
    程序一启动就会开一个主线程，主线程一开起来就会跑一个主线程对应的RunLoop, RunLoop保证主线程不会被销毁，也就保证了程序的持续运行

2. 处理App中的各种事件（比如：触摸事件，定时器事件，Selector事件等）

3. 节省CPU资源，提高程序性能
    程序运行起来时，当什么操作都没有做的时候，RunLoop就告诉CUP，现在没有事情做，我要去休息，这时CUP就会将其资源释放出来去做其他的事情，当有事情做的时候RunLoop就会立马起来去做事情
    
#### runloop和线程的关系
1. 每条`线程`都有**唯一**的一个与之对应的`RunLoop`对象
2. RunLoop保存在一个`全局的Dictionary`里，`线程`作为key, `RunLoop`作为value
3. **主线程**的RunLoop已经**自动创建**好了，**子线程**的RunLoop需要**主动创建**
4. RunLoop在**第一次获取时创建**，在`线程`**结束时销毁**

## 进程与线程
`进程`是并发执行的程序在执行过程中分配和管理资源的基本单位。

`线程`是进程的最小执行单元。一个进程可能有多个线程组成。

## JS调用及响应
UIWebview使用`JavaScriptCore`

WKWebView使用`WKScriptMessageHandler`

## 数据结构：二叉树？链表？

## 简单的算法
